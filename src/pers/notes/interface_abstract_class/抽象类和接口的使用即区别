1、final关键字
	1.1、final修饰的类无法继承。
	1.2、final修饰的方法无法覆盖。
	1.3、final修饰的变量只能赋一次值。
	1.4、final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用
	指向的对象内部的数据是可以修改的。
	1.5、final修饰的实例变量必须手动初始化，不能采用系统默认值。
	1.6、final修饰的实例变量一般和static联合使用，称为常量。
			public static final double PI = 3.1415926;

2、抽象类和接口以及抽象类和接口的区别。

	2.1、抽象类
		第一：抽象类怎么定义？在class前添加abstract关键字就行了。
		第二：抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。
		第三：final和abstract不能联合使用，这两个关键字是对立的。
		第四：抽象类的子类可以是抽象类。也可以是非抽象类。
		第五：抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。
		第六：抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。
		第七：抽象方法怎么定义？
			public abstract void doSome();
		第八（*****五颗星）：一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现。

		到目前为止，只是学习了抽象类的基础语法，一个类到底声明为抽象还是非抽象，
		这个以后慢慢来吧。写代码多的时候，自然就理解了。

		面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。
			不对，错误的。
			Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们
			都不是抽象方法，例如：
				public native int hashCode();
				这个方法底层调用了C++写的动态链接库程序。
				前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。

	2.2、接口的基础语法。
		1、接口是一种“引用数据类型”。
		2、接口是完全抽象的。
		3、接口怎么定义：[修饰符列表] interface 接口名{}
		4、接口支持多继承。
		5、接口中只有常量+抽象方法。
		6、接口中所有的元素都是public修饰的
		7、接口中抽象方法的public abstract可以省略。
		8、接口中常量的public static final可以省略。
		9、接口中方法不能有方法体。

	2.3、接口在开发中的作用。



1、抽象类和接口以及抽象类和接口的区别。

    1.1、抽象类的基础语法（见昨天笔记）

   	1.2、接口的基础语法
   		1、接口是一种“引用数据类型”。
   		2、接口是完全抽象的。
   		3、接口怎么定义：[修饰符列表] interface 接口名{}
   		4、接口支持多继承。
   		5、接口中只有常量+抽象方法。
    	6、接口中所有的元素都是public修饰的
   		7、接口中抽象方法的public abstract可以省略。
   		8、接口中常量的public static final可以省略。
   		9、接口中方法不能有方法体。
   		10、一个非抽象的类，实现接口的时候，必须将接口中所有方法加以实现。
   		11、一个类可以实现多个接口。
    	12、extends和implements可以共存，extends在前，implements在后。
   		13、使用接口，写代码的时候，可以使用多态（父类型引用指向子类型对象）。

    	课下代码就不要翻阅讲师的了，直接根据这个结论进行验证。
    	推翻它。尝试推翻它。

    1.3、接口在开发中的作用

   		注意：接口在开发中的作用，类似于多态在开发中的作用。
    		多态：面向抽象编程，不要面向具体编程。降低程序的耦合度。提高程序的扩展力。
    	/*
    	public class Master{
    		public void feed(Dog d){}
    		public void feed(Cat c){}
    		//假设又要养其它的宠物，那么这个时候需要再加1个方法。（需要修改代码了）
    		//这样扩展力太差了，违背了OCP原则（对扩展开放，对修改关闭。）
    	}
    	*/

    	public class Master{
    		public void feed(Animal a){
    			// 面向Animal父类编程，父类是比子类更抽象的。
    			//所以我们叫做面向抽象编程，不要面向具体编程。
    			//这样程序的扩展力就强。
    		}
    	}

    接口在开发中的作用？
    	接口是不是完全的？是。
    	而我们以后正好要求，面向抽象编程。
    	面向抽象编程这句话以后可以修改为：面向接口编程。
    	有了接口就有了可插拔。可插拔表示扩展力很强。不是焊接死的。

    	主板和内存条之间有插槽，这个插槽就是接口，内存条坏了，可以重新
    	买一个换下来。这叫做高扩展性。（低耦合度。）

    	接口在现实世界中是不是到处都是呢？
    		螺栓和螺母之间有接口
    		灯泡和灯口之间有接口
    		笔记本电脑和键盘之间有接口（usb接口，usb接口是不是某个计算机协会制定的协议/规范。）
    		接口有什么用？扩展性好。可插拔。
    		接口是一个抽象的概念。

    分析：
    	中午去饭馆吃饭，这个过程中有接口吗？

    		接口是抽象的。

    		菜单是一个接口。（菜单上有一个抽象的照片：西红柿炒鸡蛋）

    		谁面向接口调用。（顾客面向菜单点菜，调用接口。）

    		谁负责实现这个接口。（后台的厨师负责把西红柿鸡蛋做好！是接口的实现者。）

    	这个接口有什么用呢？
    		这个饭馆的“菜单”，让“顾客”和“后厨”解耦合了。
    		顾客不用找后厨，后厨不用找顾客。他们之间完全依靠这个抽象的菜单沟通。

    		总结一句话：三个字“解耦合”
    	    	面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。
    	    	接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）

    	    	接口可以解耦合，解开的是谁和谁的耦合！！！
    	    	任何一个接口都有调用者和实现者。
    	    	接口可以将调用者和实现者解耦合。
    	    	调用者面向接口调用。
    	    	实现者面向接口编写实现。

    	    	以后进行大项目的开发，一般都是将项目分离成一个模块一个模块的，
    	    	模块和模块之间采用接口衔接。降低耦合度。

    1.4、类型和类型之间的关系：

    	is a（继承）、has a（关联）、like a（实现）
    		is a：
    			Cat is a Animal（猫是一个动物）
    			凡是能够满足is a的表示“继承关系”
   				A extends B

   			has a：
   				I has a Pen（我有一支笔）
   				凡是能够满足has a关系的表示“关联关系”
   				关联关系通常以“属性”的形式存在。
    			A{
    				B b;
    			}

    			like a:
    				Cooker like a FoodMenu（厨师像一个菜单一样）
    				凡是能够满足like a关系的表示“实现关系”
    				实现关系通常是：类实现接口。
    				A implements B

    1.5、抽象类和接口有什么区别？
    	在这里我们只说一下抽象类和接口在语法上的区别。
    	至于以后抽象类和接口应该怎么进行选择，通过后面的项目去体会/学习。

    	抽象类是半抽象的。
    	接口是完全抽象的。

    	抽象类中有构造方法。
    	接口中没有构造方法。

    	接口和接口之间支持多继承。
    	类和类之间只能单继承。

    	一个类可以同时实现多个接口。
    	一个抽象类只能继承一个类（单继承）。

    	接口中只允许出现常量和抽象方法。

    	这里先透露一个信息：
    		以后接口使用的比抽象类多。一般抽象类使用的还是少。
    		接口一般都是对“行为”的抽象。


2、package和import

    	2.1、package
    		第一：package出现在java源文件第一行。
    		第二：带有包名怎么编译？javac -d . xxx.java
    		第三：怎么运行？java 完整类名

    		补充：以后说类名的时候，如果带着包名描述，表示完整类名。
    		如果没有带包，描述的话，表示简类名。
    			java.util.Scanner 完整类名。
    			Scanner 简类名

    	2.2、import

    		import什么时候不需要？
    			java.lang不需要。
    			同包下不需要。
    			其它一律都需要。

    		怎么用？
    			import 完整类名;
    			import 包名.*;

    			import java.util.Scanner; // 完整类名。

    			// 同学的疑问：这样是不是效率比较低。
    			// 这个效率不低，因为编译器在编译的时候，会自动把*变成具体的类名。
    			import java.util.*;

    			// 想省懒劲你不能太省了。
    			import java.*; 这是不允许的，因为在java语言中规定，这里的*只代表某些类的名字。



1、数组
	1.1、数组的优点和缺点，并且要理解为什么。
		第一：空间存储上，内存地址是连续的。
		第二：每个元素占用的空间大小相同。
		第三：知道首元素的内存地址。
		第四：通过下标可以计算出偏移量。
		通过一个数学表达式，就可以快速计算出某个下标位置上元素的内存地址，
		直接通过内存地址定位，效率非常高。

		优点：检索效率高。
		缺点：随机增删效率较低，数组无法存储大数据量。
		注意：数组最后一个元素的增删效率不受影响。

	1.2、一维数组的静态初始化和动态初始化
		静态初始化：
			int[] arr = {1,2,3,4};
			Object[] objs = {new Object(), new Object(), new Object()};
		动态初始化：
			int[] arr = new int[4]; // 4个长度，每个元素默认值0
			Object[] objs = new Object[4]; // 4个长度，每个元素默认值null

	1.3、一维数组的遍历
		for(int i = 0; i < arr.length; i++){
			System.out.println(arr[i]);
		}

	1.4、二维数组的静态初始化和动态初始化
		静态初始化：
			int[][] arr = {
									{1,2,34},
									{54,4,34,3},
									{2,34,4,5}
								};

			Object[][] arr = {
									{new Object(),new Object()},
									{new Object(),new Object()},
									{new Object(),new Object(),new Object()}
								};
		动态初始化：
			int[][] arr = new int[3][4];
			Object[][] arr = new Object[4][4];
			Animal[][] arr = new Animal[3][4];
			// Person类型数组，里面可以存储Person类型对象，以及Person类型的子类型都可以。
			Person[][] arr = new Person[2][2];
			....

	1.5、二维数组的遍历
		for(int i = 0; i < arr.length; i++){ // 外层for循环负责遍历外面的一维数组。
			// 里面这个for循环负责遍历二维数组里面的一维数组。
			for(int j = 0; j < arr[i].length; j++){
				System.out.print(arr[i][j]);
			}
			// 换行。
			System.out.println();
		}

	1.6、main方法上“String[] args”参数的使用（非重点，了解一下，以后一般都是有界面的，用户可以在界面上输入用户名和密码等参数信息。）

	1.7、数组的拷贝：System.arraycopy()方法的使用
		数组有一个特点：长度一旦确定，不可变。
		所以数组长度不够的时候，需要扩容，扩容的机制是：新建一个大数组，
		将小数组中的数据拷贝到大数组，然后小数组对象被垃圾回收。

	1.8、对数组中存储引用数据类型的情况，要会画它的内存结构图。

2、数组

	2.1、常见的算法：

		排序算法：
			冒泡排序算法
			选择排序算法

		查找算法：
			二分法查找

		以上算法在以后的java实际开发中我们不需要使用的。
		因为java已经封装好了，直接调用就行。
		只不过以后面试的时候，可能会有机会碰上。

	2.2、算法实际上在java中不需要精通，因为java中已经封装好了，
	要排序就调用方法就行。例如：java中提供了一个数组工具类：
		java.util.Arrays
			Arrays是一个工具类。
			其中有一个sort()方法，可以排序。静态方法，直接使用类名调用就行。

3、冒泡排序：

参与比较的数据：9 8 10 7 6 0 11
第1次循环：
8 9 10 7 6 0 11 (第1次比较：交换)
8 9 10 7 6 0 11 (第2次比较：不交换)
8 9 7 10 6 0 11 (第3次比较：交换)
8 9 7 6 10 0 11 (第4次比较：交换)
8 9 7 6 0 10 11 (第5次比较：交换)
8 9 7 6 0 10 11 (第6次比较：不交换)
最终冒出的最大数据在右边：11

参与比较的数据：8 9 7 6 0 10
第2次循环：
8 9 7 6 0 10（第1次比较：不交换）
8 7 9 6 0 10（第2次比较：交换）
8 7 6 9 0 10（第3次比较：交换）
8 7 6 0 9 10（第4次比较：交换）
8 7 6 0 9 10（第5次比较：不交换）

参与比较的数据：8 7 6 0 9
第3次循环：
7 8 6 0 9（第1次比较：交换）
7 6 8 0 9（第2次比较：交换）
7 6 0 8 9（第3次比较：交换）
7 6 0 8 9（第4次比较：不交换）

参与比较的数据：7 6 0 8
第4次循环：
6 7 0 8（第1次比较：交换）
6 0 7 8（第2次比较：交换）
6 0 7 8（第3次比较：不交换）

参与比较的数据：6 0 7
第5次循环：
0 6 7（第1次比较：交换）
0 6 7（第2次比较：不交换）

参与比较的数据：0 6
第6次循环：
0 6 （第1次比较：不交换）

for(int i = 6; i > 0; i--){ // 6次
	//7条数据比6次
	//6条数据比5次
	//5条数据比4次
	//4条数据比3次
	//3条数据比2次
	//2条数据比1次
	for(int j = 0; j < i; j++){

	}
}

4、选择排序：

	选择排序比冒泡排序的效率高。
	高在交换位置的次数上。
	选择排序的交换位置是有意义的。

	循环一次，然后找出参加比较的这堆数据中最小的，拿着这个最小的值和
	最前面的数据“交换位置”。


	参与比较的数据：3 1 6 2 5 （这一堆参加比较的数据中最左边的元素下标是0）
	第1次循环之后的结果是：
	1 3 6 2 5

	参与比较的数据：3 6 2 5 （这一堆参加比较的数据中最左边的元素下标是1）
	第2次循环之后的结果是：
	2 6 3 5

	参与比较的数据：6 3 5 （这一堆参加比较的数据中最左边的元素下标是2）
	第3次循环之后的结果是：
	3 6 5

	参与比较的数据：6 5 （这一堆参加比较的数据中最左边的元素下标是3）
	第4次循环之后的结果是：
	5 6

	注意：5条数据，循环4次。

5、二分法查找（折半查找）：

	第一：二分法查找建立在排序的基础之上。
	第二：二分法查找效率要高于“一个挨着一个”的这种查找方式。
	第三：二分法查找原理？
		10(0下标) 23 56 89 100 111 222 235 500 600(下标9) arr数组

		目标：找出600的下标
			(0 + 9) / 2 --> 4（中间元素的下标）

		arr[4]这个元素就是中间元素：arr[4]是 100
		100 < 600
		说明被查找的元素在100的右边。
		那么此时开始下标变成：4 + 1

			(5 + 9) / 2 --> 7（中间元素的下标）
			arr[7] 对应的是：235
			235 < 600
			说明被查找的元素在235的右边。

		开始下标又进行了转变：7 + 1
			(8 + 9) / 2 --> 8
			arr[8] --> 500
			500 < 600
			开始元素的下标又发生了变化：8 + 1
			(9 + 9) / 2 --> 9
			arr[9]是600，正好和600相等，此时找到了。


6、介绍一下java.util.Arrays工具类。
	所有方法都是静态的，直接用类名调用
	主要使用的是两个方法：
		二分法查找，排序
	以后要看文档，不要死记硬背。